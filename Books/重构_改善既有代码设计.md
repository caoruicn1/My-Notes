## 第6章 组织列表

- **6.1 Extract Method(提炼函数)**
	- 函数不能太长，将长函数分成颗粒状的小函数，代替注释。其中
		- 不需要改变局部变量的，直接提取
		- 需要改变局部变量，最后将局部变量直接返回。且在小函数中改变好命名(Result)。
	- 尽量不要临时变量，直接顶替即可。

- **6.2 Inline Method(内联函数)**
	- 一大堆小函数太小没必要，直接带回原引用点，删除小函数
	- 带回原引用点后再重新试图提取组织合理的小函数。

- **6.3 Inline Temp(内联临时变量)**
	- class创建实例后再调用函数赋值给临时变量，然后判断临时变量，不如删除临时变量，直接一气呵成进行判断。

- **6.4 Replace Temp with Query(以查询取代临时变量)**
	- 将临时变量的表达式提取出来，然后直接以查询取代临时变量。这样还能多次被其他函数使用。极大的简化和清晰逻辑！！！

- **6.5 Introduce Explaining Variable(引入解释变量)**
	- 将复杂的表达式提取到临时变量，然后用临时变量。
	- 这和**Replace Temp with Query(以查询取代临时变量)**是相反的，和**Extract Method(提炼函数)**也差不多，但是**Extract Method(提炼函数)**比较好，所以只有当用**Extract Method(提炼函数)**太复杂的时候才用这个。

- **6.6 Split Temporary Variable(分解临时变量)**
	- 如果临时变量被多次赋值，那就分解为多个临时变量，每个临时变量只被赋值一次。

- **6.7 Remove Assignments to Parameters(移除对参数的赋值)**
	- 对传进来的参数进行再赋值容易产生歧义，应该用临时变量取代。
	- 当然如果是对传入的参数进行各种内部操作的话除外。

- **6.8 Replace Method with Method Object(以函数对象取代函数)**
	- 将函数内部复杂的计算放入一个新类中，比如Gamma，新类中用compute函数计算，然后返回Gamma(x,x,x).compute()。这样可便于将逻辑分离，将compute函数内部再分解。

- **6.9 Substitute Algorithm(替换算法)**
	- 如果想到更好的算法，应该立刻替换。


## 第7章 在对象之间搬移特性

- **7.1 Move Method(搬移函数)**
	- 如果某类用函数用得太多，就应该移过去。

- **7.2 Move Field(搬移字段)**
	- 某字段被类中的其他类用的更多，就把这个字段移动到其他类中，然后用函数返回出来。

- **7.3 Extract Class(提炼类)**
	- 一个类应该是一个清楚的抽象，但往往由于日益添加功能导致类担负太多责任。
	- 可以将类再分解为多个类，明确各自的责任。
	- 可以通过类的嵌套来隐藏类，甚至选择不提供接口保证内置类不可修改。
	- 信号：太大不易理解。某些数据或者函数总是同时出现。某些特性总要以不同的字类化方式实现。

- **7.4 Inline Class(将类内联化)**
	- 某个类没有做太多事情，就把类合并了。


- **7.5 Hide Delegate(隐藏“委托关系”)** +
	- 某函数调用需要 a.v().c(), 可直接在a类中设定函数c返回v().c()，从而隐藏v(), 隐藏委托关系。
	- 好处是能隐藏委托，使代码清晰。
	- 坏处是每次添加新子功能都要写好委托。

- **7.6 Remove Middle Man(移除中间人)** - 
	- 某个类做了过多的简单委托动作，还不如直接使用受托类。
	- 即要用a.v().c()的地方太多了，还不如不写委托函数。


- **7.7 Introduce Foreign Method(引入外加函数)**
	- 在客户类中建立一个函数，并以第一参数形式传入服务类实例

- **7.8 Introduce Local Extension(引入本地扩展)**
	- 建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类活包装类。

## 第8章 重新组织数据

- **8.1 Self Encapsulate Field(自封装字段)**
	- 为某些字段建立取值/设值函数，并且只以这些函数来访问字段。
	- 好处是子类可以灵活地修改取值/设值函数，从而更改行为，而不是修改原字段。
	- 可先直接访问字段，当有需求时再重构成取值/设值函数。

- **8.2 Replace Data Value with Object(以对象取代数据值)**
	- 将数据项变成对象。
	- 为数据值新建一个类，调用新类的取值函数。
	- 好处是可以将各种需要扩充的逻辑放在新类中。

- **8.3 Change Value to Reference(将值对象改为引用对象)**
	- 将这个值对象变成引用对象，可引用于某注册表。
	- 好处是这样可使全部人都引用同一个对象。这样便于对一个对象修改，就可以影响到所有人。
	- 注册表可先提前创建好，也可后期动态创建。

- **8.4 Change Reference to Value(将引用对象改为值对象)**
	- 如果确定值不可变，那就应该改成不可变对象
	- 用get返回，将值设置为私有，防止被修改

- **8.5 Replace Array with Object(以对象取代数组)**
	- 以对象取代数组，对于每一个元素用一个字段表示。
	- 因为很难记清楚哪个位置是哪个种类的元素。
	- 可以新建一个类，表示数组拥有的所有信息。之后将数组内容反映到私有的属性中，以摆脱对数组的依赖。（变成了8.2）

- **8.6 Duplicate Observed Data(复制“被监视数据”)**
	- 将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。

- **8.7 Change Unidirectional Association to Bidirectional(将单向关联改为双向关联)**
	- 两个类都需要使用对方的特性。
	- 添加一个反向指针，并使修改函数能够同时更新两条连接。

- **8.8 Change Bidirectional Association to Unidirectional(将双向关联改为单向关联)**
	- 双向关联的代价就是要总是维护双向连接，确保对象被正确创建和删除而增加复杂度。
	- 当没必要时，去除不必要的关联。
	- 同8.7相反。

- **8.9 Replace Magic Number with Symbolic Constant(以字面常量取代魔法数)**
	- 魔法数：指拥有特殊意义，却又不能明确表现出这种意义的数字。
	- 比如一些常量。
	- 声明变量进行取代。

- **8.10 Encapsulate Field (封装字段)**
	- 将数据设置为私有，用set和get。

- **8.11 Encapsulate Collection (封装集合)**
	- 让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数，不提供设值函数。
	- 可避免误修改原始数据。

- **8.12 Replace Record with Data Class(以数据类取代记录)**
	- 为该记录创建一个“哑”数据对象。

- **8.13 Replace Type Code with Class(以类取代类型码)**
	- 以一个新的类替代该数值类型码。
	-  比如血型OAB，为123，改成用类直接表示血型对象。

- **8.14 Replace Type Code with Subclasses(以子类取代类型码)**
	- 以子类取代这个类型码，即为每一个类型码分别创建一个子类。
	- 和8.13不同，8.13是将类作为属性传入主类，而8.14是创建多个主类，每个主类享有一个类型。

- **8.15 Replace Type Code with State/Strategy(以State/Strategy取代类型码)**
	- 以状态对象取代类型码。
	- 和8.13相似，但8.15为每个类型又分别创建了子类，在超类中建立一个抽象的查询函数，用以返回类型码。在每个子类中覆写该函数，返回确切的类型码。在源类中建立一个字段，用以保存新建的状态对象。

- **8.16 Replace Subclass with Fields(以字段取代子类)**
	- 建立子类的目的是为了增加新特性或变化其行为。如果没必要，还不如删除。

## 第9章 简化条件表达式

- **9.1 Decompose Conditional(分解条件表达式)**
	- 从if、then、else三个段落中分别提炼出独立函数。
	- if (notSummer(date))~
	- 增加可读性

- **9.2 Consolidate Conditional Expression(合并条件表达式)**
	- 将多个if合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。

- **9.3 Consolidate Duplicate Conditional Fragments(合并重复的条件片段)**
	- 如果条件表达式的每个分支上有着相同的一段代码，就把这段代码搬移到条件表达式之外。

- **9.4 Remove Control Flag(移除控制标记)**
	- 以break语句或return语句取代控制标记。
	- 比如while xxx，然后xxx在循环中变为True，则可换成用break
	- 比如在循环中，不同分支对xxx取值，最后在循环外return xxx，不如直接在循环内return xxx，在循环外renturn 0

- **9.5 Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）**
	- 


- **9.8**

## 第10章 简化函数调用

- **10.15**

## 第11章 处理概括关系

- **11.12**

## 第12章 大型重构

- **12.4**
