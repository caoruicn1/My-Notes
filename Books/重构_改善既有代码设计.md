## 第6章 组织列表

- **6.1 Extract Method(提炼函数)**
	- 函数不能太长，将长函数分成颗粒状的小函数，代替注释。其中
		- 不需要改变局部变量的，直接提取
		- 需要改变局部变量，最后将局部变量直接返回。且在小函数中改变好命名(Result)。
	- 尽量不要临时变量，直接顶替即可。

- **6.2 Inline Method(内联函数)**
	- 一大堆小函数太小没必要，直接带回原引用点，删除小函数
	- 带回原引用点后再重新试图提取组织合理的小函数。

- **6.3 Inline Temp(内联临时变量)**
	- class创建实例后再调用函数赋值给临时变量，然后判断临时变量，不如删除临时变量，直接一气呵成进行判断。

- **6.4 Replace Temp with Query(以查询取代临时变量)**
	- 将临时变量的表达式提取出来，然后直接以查询取代临时变量。这样还能多次被其他函数使用。极大的简化和清晰逻辑！！！

- **6.5 Introduce Explaining Variable(引入解释变量)**
	- 将复杂的表达式提取到临时变量，然后用临时变量。
	- 这和**Replace Temp with Query(以查询取代临时变量)**是相反的，和**Extract Method(提炼函数)**也差不多，但是**Extract Method(提炼函数)**比较好，所以只有当用**Extract Method(提炼函数)**太复杂的时候才用这个。

- **6.6 Split Temporary Variable(分解临时变量)**
	- 如果临时变量被多次赋值，那就分解为多个临时变量，每个临时变量只被赋值一次。

- **6.7 Remove Assignments to Parameters(移除对参数的赋值)**
	- 对传进来的参数进行再赋值容易产生歧义，应该用临时变量取代。
	- 当然如果是对传入的参数进行各种内部操作的话除外。

- **6.8 Replace Method with Method Object(以函数对象取代函数)**
	- 将函数内部复杂的计算放入一个新类中，比如Gamma，新类中用compute函数计算，然后返回Gamma(x,x,x).compute()。这样可便于将逻辑分离，将compute函数内部再分解。

- **6.9 Substitute Algorithm(替换算法)**
	- 如果想到更好的算法，应该立刻替换。


## 第7章 在对象之间搬移特性

- **7.1 Move Method(搬移函数)**
	- 如果某类用函数用得太多，就应该移过去。

- **7.2 Move Field(搬移字段)**
	- 某字段被类中的其他类用的更多，就把这个字段移动到其他类中，然后用函数返回出来。

- **7.3 Extract Class(提炼类)**
	- 一个类应该是一个清楚的抽象，但往往由于日益添加功能导致类担负太多责任。
	- 可以将类再分解为多个类，明确各自的责任。
	- 可以通过类的嵌套来隐藏类，甚至选择不提供接口保证内置类不可修改。
	- 信号：太大不易理解。某些数据或者函数总是同时出现。某些特性总要以不同的字类化方式实现。

- **7.4 Inline Class(将类内联化)**
	- 某个类没有做太多事情，就把类合并了。


- **7.5 Hide Delegate(隐藏“委托关系”)** +
	- 某函数调用需要 a.v().c(), 可直接在a类中设定函数c返回v().c()，从而隐藏v(), 隐藏委托关系。
	- 好处是能隐藏委托，使代码清晰。
	- 坏处是每次添加新子功能都要写好委托。

- **7.6 Remove Middle Man(移除中间人)** - 
	- 某个类做了过多的简单委托动作，还不如直接使用受托类。
	- 即要用a.v().c()的地方太多了，还不如不写委托函数。


- **7.7 Introduce Foreign Method(引入外加函数)**
	- 在客户类中建立一个函数，并以第一参数形式传入服务类实例

- **7.8 Introduce Local Extension(引入本地扩展)**
	- 建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类活包装类。

## 第8章 重新组织数据

- **8.1 Self Encapsulate Field(自封装字段)**
	- 为某些字段建立取值/设值函数，并且只以这些函数来访问字段。
	- 好处是子类可以灵活地修改取值/设值函数，从而更改行为，而不是修改原字段。
	- 可先直接访问字段，当有需求时再重构成取值/设值函数。

- **8.2 Replace Data Value with Object(以对象取代数据值)**
	- 将数据项变成对象。
	- 为数据值新建一个类，调用新类的取值函数。
	- 好处是可以将各种需要扩充的逻辑放在新类中。

- **8.3 Change Value to Reference(将值对象改为引用对象)**
	- 将这个值对象变成引用对象，可引用于某注册表。
	- 好处是这样可使全部人都引用同一个对象。这样便于对一个对象修改，就可以影响到所有人。
	- 注册表可先提前创建好，也可后期动态创建。

- **8.4 Change Reference to Value(将引用对象改为值对象)**
	- 如果确定值不可变，那就应该改成不可变对象
	- 用get返回，将值设置为私有，防止被修改

- **8.5 Replace Array with Object(以对象取代数组)**
	- 以对象取代数组，对于每一个元素用一个字段表示。
	- 因为很难记清楚哪个位置是哪个种类的元素。
	- 可以新建一个类，表示数组拥有的所有信息。之后将数组内容反映到私有的属性中，以摆脱对数组的依赖。（变成了8.2）

- **8.6 Duplicate Observed Data(复制“被监视数据”)**
	- 将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。

- **8.16**

## 第9章 简化条件表达式

- **9.8**

## 第10章 简化函数调用

- **10.15**

## 第11章 处理概括关系

- **11.12**

## 第12章 大型重构

- **12.4**
