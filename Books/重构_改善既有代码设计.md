# 重构\_改善既有代码设计--Refactoring Improving the Design of Existing Code

**Author:** Martin Fowler


<!-- vim-markdown-toc GitLab -->

* [第6章 组织列表](#第6章-组织列表)
* [第7章 在对象之间搬移特性](#第7章-在对象之间搬移特性)
* [第8章 重新组织数据](#第8章-重新组织数据)
* [第9章 简化条件表达式](#第9章-简化条件表达式)
* [第10章 简化函数调用](#第10章-简化函数调用)
* [第11章 处理概括关系](#第11章-处理概括关系)
* [第12章 大型重构](#第12章-大型重构)

<!-- vim-markdown-toc -->

## 第6章 组织列表

- **6.1 Extract Method(提炼函数)**
	- 函数不能太长，将长函数分成颗粒状的小函数，代替注释。其中
		- 不需要改变局部变量的，直接提取
		- 需要改变局部变量，最后将局部变量直接返回。且在小函数中改变好命名(Result)。
	- 尽量不要临时变量，直接顶替即可。

- **6.2 Inline Method(内联函数)**
	- 一大堆小函数太小没必要，直接带回原引用点，删除小函数
	- 带回原引用点后再重新试图提取组织合理的小函数。

- **6.3 Inline Temp(内联临时变量)**
	- class创建实例后再调用函数赋值给临时变量，然后判断临时变量，不如删除临时变量，直接一气呵成进行判断。

- **6.4 Replace Temp with Query(以查询取代临时变量)**
	- 将临时变量的表达式提取出来，然后直接以查询取代临时变量。这样还能多次被其他函数使用。极大的简化和清晰逻辑！！！

- **6.5 Introduce Explaining Variable(引入解释变量)**
	- 将复杂的表达式提取到临时变量，然后用临时变量。
	- 这和**Replace Temp with Query(以查询取代临时变量)**是相反的，和**Extract Method(提炼函数)**也差不多，但是**Extract Method(提炼函数)**比较好，所以只有当用**Extract Method(提炼函数)**太复杂的时候才用这个。

- **6.6 Split Temporary Variable(分解临时变量)**
	- 如果临时变量被多次赋值，那就分解为多个临时变量，每个临时变量只被赋值一次。

- **6.7 Remove Assignments to Parameters(移除对参数的赋值)**
	- 对传进来的参数进行再赋值容易产生歧义，应该用临时变量取代。
	- 当然如果是对传入的参数进行各种内部操作的话除外。

- **6.8 Replace Method with Method Object(以函数对象取代函数)**
	- 将函数内部复杂的计算放入一个新类中。
    - 比如Gamma，新类中用compute函数计算，然后返回Gamma(x,x,x).compute()。这样可便于将逻辑分离，将compute函数内部再分解。

- **6.9 Substitute Algorithm(替换算法)**
	- 如果想到更好的算法，应该立刻替换。


## 第7章 在对象之间搬移特性

- **7.1 Move Method(搬移函数)**
	- 如果某类用函数用得太多，就应该移过去。

- **7.2 Move Field(搬移字段)**
	- 某字段被类中的其他类用的更多，就把这个字段移动到其他类中，然后用函数返回出来。

- **7.3 Extract Class(提炼类)**
	- 一个类应该是一个清楚的抽象，但往往由于日益添加功能导致类担负太多责任。
	- 可以将类再分解为多个类，明确各自的责任。
	- 可以通过类的嵌套来隐藏类，甚至选择不提供接口保证内置类不可修改。
	- 信号：太大不易理解。某些数据或者函数总是同时出现。某些特性总要以不同的字类化方式实现。

- **7.4 Inline Class(将类内联化)**
	- 某个类没有做太多事情，就把类合并了。


- **7.5 Hide Delegate(隐藏“委托关系”)** +
	- 某函数调用需要 a.v().c(), 可直接在a类中设定函数c返回v().c()，从而隐藏v(), 隐藏委托关系。
	- 好处是能隐藏委托，使代码清晰。
	- 坏处是每次添加新子功能都要写好委托。

- **7.6 Remove Middle Man(移除中间人)** - 
	- 某个类做了过多的简单委托动作，还不如直接使用受托类。
	- 即要用a.v().c()的地方太多了，还不如不写委托函数。


- **7.7 Introduce Foreign Method(引入外加函数)**
	- 在客户类中建立一个函数，并以第一参数形式传入服务类实例

- **7.8 Introduce Local Extension(引入本地扩展)**
	- 建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类活包装类。

## 第8章 重新组织数据

- **8.1 Self Encapsulate Field(自封装字段)**
	- 为某些字段建立取值/设值函数，并且只以这些函数来访问字段。
	- 好处是子类可以灵活地修改取值/设值函数，从而更改行为，而不是修改原字段。
	- 可先直接访问字段，当有需求时再重构成取值/设值函数。

- **8.2 Replace Data Value with Object(以对象取代数据值)**
	- 将数据项变成对象。
	- 为数据值新建一个类，调用新类的取值函数。
	- 好处是可以将各种需要扩充的逻辑放在新类中。

- **8.3 Change Value to Reference(将值对象改为引用对象)**
	- 将这个值对象变成引用对象，可引用于某注册表。
	- 好处是这样可使全部人都引用同一个对象。这样便于对一个对象修改，就可以影响到所有人。
	- 注册表可先提前创建好，也可后期动态创建。

- **8.4 Change Reference to Value(将引用对象改为值对象)**
	- 如果确定值不可变，那就应该改成不可变对象
	- 用get返回，将值设置为私有，防止被修改

- **8.5 Replace Array with Object(以对象取代数组)**
	- 以对象取代数组，对于每一个元素用一个字段表示。
	- 因为很难记清楚哪个位置是哪个种类的元素。
	- 可以新建一个类，表示数组拥有的所有信息。之后将数组内容反映到私有的属性中，以摆脱对数组的依赖。(变成了8.2)

- **8.6 Duplicate Observed Data(复制“被监视数据”)**
	- 将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。

- **8.7 Change Unidirectional Association to Bidirectional(将单向关联改为双向关联)**
	- 两个类都需要使用对方的特性。
	- 添加一个反向指针，并使修改函数能够同时更新两条连接。

- **8.8 Change Bidirectional Association to Unidirectional(将双向关联改为单向关联)**
	- 双向关联的代价就是要总是维护双向连接，确保对象被正确创建和删除而增加复杂度。
	- 当没必要时，去除不必要的关联。
	- 同8.7相反。

- **8.9 Replace Magic Number with Symbolic Constant(以字面常量取代魔法数)**
	- 魔法数：指拥有特殊意义，却又不能明确表现出这种意义的数字。
	- 比如一些常量。
	- 声明变量进行取代。

- **8.10 Encapsulate Field (封装字段)**
	- 将数据设置为私有，用set和get。

- **8.11 Encapsulate Collection (封装集合)**
	- 让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数，不提供设值函数。
	- 可避免误修改原始数据。

- **8.12 Replace Record with Data Class(以数据类取代记录)**
	- 为该记录创建一个“哑”数据对象。

- **8.13 Replace Type Code with Class(以类取代类型码)**
	- 以一个新的类替代该数值类型码。
	-  比如血型OAB，为123，改成用类直接表示血型对象。

- **8.14 Replace Type Code with Subclasses(以子类取代类型码)**
	- 以子类取代这个类型码，即为每一个类型码分别创建一个子类。
	- 和8.13不同，8.13是将类作为属性传入主类，而8.14是创建多个主类，每个主类享有一个类型。

- **8.15 Replace Type Code with State/Strategy(以State/Strategy取代类型码)**
	- 以状态对象取代类型码。
	- 和8.13相似，但8.15为每个类型又分别创建了子类，在超类中建立一个抽象的查询函数，用以返回类型码。在每个子类中覆写该函数，返回确切的类型码。在源类中建立一个字段，用以保存新建的状态对象。

- **8.16 Replace Subclass with Fields(以字段取代子类)**
	- 建立子类的目的是为了增加新特性或变化其行为。如果没必要，还不如删除。

## 第9章 简化条件表达式

- **9.1 Decompose Conditional(分解条件表达式)**
	- 从if、then、else三个段落中分别提炼出独立函数。
	- if (notSummer(date))~
	- 增加可读性

- **9.2 Consolidate Conditional Expression(合并条件表达式)**
	- 将多个if合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。

- **9.3 Consolidate Duplicate Conditional Fragments(合并重复的条件片段)**
	- 如果条件表达式的每个分支上有着相同的一段代码，就把这段代码搬移到条件表达式之外。

- **9.4 Remove Control Flag(移除控制标记)**
	- 以break语句或return语句取代控制标记。
	- 比如while xxx，然后xxx在循环中变为True，则可换成用break
	- 比如在循环中，不同分支对xxx取值，最后在循环外return xxx，不如直接在循环内return xxx，在循环外renturn 0

- **9.5 Replace Nested Conditional with Guard Clauses(以卫语句取代嵌套条件表达式)**
	- 比如多个if else嵌套，不如全部用if，然后把条件反转。

- **9.6 Replace COnditional with Polymorphism(以多态取代条件表达式)**
	- 用多态将不同条件的表达式，用子类来完成。
	- 比如要调用某函数，则子类分别覆写所要调用的函数。主条件句只需要传入类，并调用函数即可。

- **9.7 Introduce Null Object(引入Null对象)**
	- 对于那些需要再三检查某对象是否为null，可以将null值替换为null对象。
	- 即建立一个子类，比如为Customer建立NullCustomer，然后就可以替换掉检查条件，调用子类内的一致函数。这样操作更具灵活性
	- 可添加isNull()函数判断，再逐一更改。

- **9.8 Introduce Assertion(引入断言)**
	- 某一段代码需要对程序状态做出某种假设，那就用断言assert明确表现这种假设。
	- 应该常常问自己，如果断言所指示的约束条件不能满足，代码是否仍能正常运行？如果可以，就把断言拿掉。
	- 在成品中往往将断言删去，但是是一种辅助交流的好工具。
	- 比如根号下数字一定要为正。

## 第10章 简化函数调用

- **10.1，2，3**
	- **Rename Method(函数改名)**
	- **Add Parameter(添加参数)**
	- **Remove Parameter(移除参数)**

- **10.4 Separate Query from Modifier(将查询函数和修改函数分离)**
	- 若某个函数返回对象状态值，又修改对象状态。就建立两个不同的函数，其中一个负责查询，另一个负责修改。
    - 对于并发问题，可以再创建第三个函数，同时负责查询和修改。 

- **10.5 Parameterize Method(令函数携带参数)**
    - 若干函数做了类似的工作，但是本体只有一点点不同。
    - 可以建立单一函数，用参数表达不同的值。消除重复代码。

- **10.6 Replace Parameter with Explict Methods(以明确函数取代参数)**
	- 如果一个函数处理了多个动作，比如将动作明确为小函数。
    - 比如setValue(),里面分别为setHeight和setWidth. 

- **10.7 Preserve Whole Object(保持对象完整)**
    - 从某些对象中取值，不如直接传递整个对象。
    - 便于需要请求新数据时，不用总是查看和修改调用函数，而是直接利用对象进行调用。而且代码反而更清晰。

- **10.8 Replace Parameter with Methods(以函数取代参数)**
	- 对象调用某个函数，并将所得结果作为参数传递给另一个对象，可以试试移除参数，然后将该函数放到对象内部。

- **10.9 Introduce Parameter Object(引入参数对象)**
	- 某些参数总是很自然的同时出现，可以将这些参数封装到一个对象中，然后只传递参数对象即可。
	- 好处是减少参数列，降低理解和修改代码难度。

- **10.10 Remove Setting Method(移除设值函数)**
	- 类中某些字段应该在对象创建时被设值，之后不再改变。那应该去掉该字段的设值函数。
	- 即若设值函数只用一次，不如改名为initialize，只调用一次，不要用setValue。

- **10.11 Hide Method(隐藏函数)**
	- 若有函数，从来没有被其他任何类调用，就将这个函数修改为private

- **10.12 Replace Constructor with Factory Method(以工厂函数取代构造函数)**
	- 希望在创建对象时不仅仅是做简单的建构动作，可以将构造函数替换为工厂函数。
	- 比如若创建类的实例之后再调用函数修改其属性，不如直接创建时就传入属性参数。

- **10.13 Encapsulate Downcast(封装向下转型)？**
	- 某个函数返回的对象，需要由函数调用者执行向下转型（downcast）。
	- 将向下转型动作转移到函数中。

- **10.14 Replace Error Code with Exception(以异常取代错误码)**
	- 某个函数返回一个特定的代码，表示某种错误情况，不如改用引发异常。

- **10.15 Replace Expception with Test(以测试取代异常)**
	- 用try运行条件，错误的话抛出一个异常。
	- 可以修改调用者，使它在调用函数之前先做检查。

## 第11章 处理概括关系

- **11.1 Pull Up Field(字段上移)**
	- 两个子类拥有相同的字段，就将该字段移至超类。

- **11.2 Pull Up Method(函数上移)**
    - 有些函数，在各个子类中产生完全相同的结果，就将该函数移动至超类。

- **11.3 Pull Up Constructor Body(构造函数本体上移)**
    - 在各个子类中有一些构造函数长得一样，可以在超类中建立一个构造函数，然后在子类构造函数中调用。

- **11.4 Push Down Method(函数下移)**
    - 超类中的某个函数只与部分子类有关，就将这个函数移到相关的那些子类去。

- **11.5 Push Down Field(字段下移)**
    - 超类中某个字段只被部分子类用到，就将这个字段移到需要它的那些子类去。

- **11.6 Extract Subclass(提炼子类)**
    - 类中的某些特性只被某些实例用到，可以新建一个子类，将上面索卓的那一部分特性移到子类中。

- **11.7 Extra Superclass(提炼超类)**
    - 两个类有想次特性，可以为这两个类建立一个超类，将相同特性移至超类。 

- **11.8 Extract Interface(提炼接口)**
    - 若干客户使用类接口中的同一个子集，或者两个类的接口有部分相同，可以将相同的子集提炼到一个独立的接口。

- **11.9 Collapse Hierarchy(折叠继承体系)**
    - 如果超类和子类之间无太大区别，可以将它们合为一体。

- **11.10 Form TemPlate Method(塑造模板函数)**
    - 有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。
    - 可以将这些操作放进独立函数中，保持相同签名，然后移动到超类中。
    - 继承是避免重复行为的一个强大工具。

- **11.11 Replace Inheritance with Delegation(以委托取代继承)**
    - 某个子类只使用了超类接口中的一部分，或是根本不需要继承而来的数据。
    - 可以在子类中新建一个字段用以保存超类;然后调整子类函数，另它改为委托超类；然后去掉两者的继承关系。

- **11.12 Replace Delegation with Inheritance(以继承取代委托)**
    - 你在两个类之间使用委托关系，并经常为整个接口编写许多简单的委托函数。
    - 可以考虑让为拖累继承受托类。 


## 第12章 大型重构

- **12.1 Tease Apart Inheritance(梳理并分解集成体系)**
    - 某个继承体系同时承担两项责任，可以建立两个继承体系，并通过委托关系让其中一个可以调用另一个。
    - 比如某超类下的大子类有了新责任，产生了大子类的小子类，可以试试新建一个超类，将小子类的东西转移到新超类中，并以委托关系联系原超类。 

- **12.2 Convert Procedural Design to Objects(将过程化设计转化为对象设计)**
    - 如果你手上有一些传统过程化风格的代码。
    - 可以将数据变成对象，将大块的行为分成小块，并将行为移入相关对象中。

- **12.3 Separate Domain from Presentation(将领域和表述/显示分离)**
    - 某些GUI类中包含了领域逻辑，可以将领域逻辑分离出来，为他们创建独立的领域类。

- **12.4 Extract Hierachy(提炼集成体系)**
    - 某个类有太多的工作，而且一部分是由大量条件表达式完成的。
    - 可以建立集成体系，用一个子类表示一种特殊情况。
